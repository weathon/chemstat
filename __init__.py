from scipy.stats import linregress


def pre_x(x, y, pre_y):
    Syy = np.sum((y-np.mean(y))**2)
    Sxx = np.sum((x-np.mean(x))**2)
    res = linregress(x, y)
    Sr = np.sqrt(
        (Syy-res.slope**2*Sxx)/(len(x)-2)
    )
    Sxx = np.sum((x-np.mean(x))**2)
    Sc = Sr/res.slope*np.sqrt(
        1/len(x)+1/len(pre_y)+(np.mean(pre_y)-np.mean(y))**2/(res.slope**2*Sxx)
    )
    pre_Xs = (np.mean(pre_y) - res.intercept)/res.slope
    return Sc, pre_Xs


def generate_LaTex_equation(x, y, unit, pre_y, dilutionFactor, secondSample):
    reg = linregress(x, y)

    Sxy = np.sum((x-np.mean(x))*(y-np.mean(y)))
    Syy = np.sum((y-np.mean(y))**2)
    Sxx = np.sum((x-np.mean(x))**2)
    Sr = np.sqrt(
        (Syy-reg.slope**2*Sxx)/(len(x)-2)
    )
    Sxx = np.sum((x-np.mean(x))**2)
    Sc = dilutionFactor*Sr/reg.slope*np.sqrt(
        1/len(x)+1/len(pre_y)+(np.mean(pre_y)-np.mean(y))**2/(reg.slope**2*Sxx)
    )
    xc = dilutionFactor*(np.mean(pre_y) - reg.intercept)/reg.slope
    if not secondSample:
        raw_data = r"""\begin{center}
            \begin{tabular}{ |c|c||c|c| } 
            \hline
                Conc (^^unit^^) & Absorption & Conc (^^unit^^) & Absorption \\ \hline
                ^^data^^
                \hline
            \end{tabular}
            \end{center}
            """
        tmp = ""
        for i in range(ceil(len(x)/2)):
            tmp += str(x[i]) + "&" + str(y[i]) + "&"
            if i*2 <= len(x):
                tmp += str(x[i+ceil(len(x)/2)]) + "&" + \
                    str(y[i+ceil(len(x)/2)]) + r"\\ \hline"
                # tmp += str(x[i*2]) + "&" + str(y[i*2]) + r"\\ \hline"
        raw_data = raw_data.replace("^^unit^^", unit).replace("^^data^^", tmp)
    else:
        raw_data = ""
    # template1 = """
    #                 The following \\LaTeX is generated by Chemstat.py
    #                 Cal Cruve:
    #                 $$
    #                 S_{xy}= \\sum (x_i-\\bar x)(y_i-\\bar y)
    #                 $$
    #                 $$
    #                 Sx_{xx} = \\sum (x_i-\\bar x)^2
    #                 $$
    #                 $$
    #                 m=\\frac{S_{xy}}{S_{xx}}=\\frac{%s}{%s}\; = %s$$$$
    #                 y_{int} = \\bar y - m\\bar x= %s -%s %s\; %s = %s %s
    #                 $$"""
    # text1 = template1 % (Sxy, Sxx, reg.slope, np.mean(y), reg.slope, np.mean(x), unit, reg.intercept, unit)

    # Sxy= Sxx= ybar xbar Sr m M N ycbar Sc xc tvalue used
    table = r"""\begin{center}
        \begin{tabular}{ |c|c| } 
        \hline
        S_{xy} & %(Sxy)s \\\hline S_{xx} & %(Sxx)s\\\hline \bar{y} & %(ybar)s\\\hline \bar{x} & %(xbar)s\\\hline   Sr & %(Sr)s\\\hline 
         m(slope) & %(m)s\\\hline  M(Number of Repeats for sample) & %(M)s\\\hline  N (Number of points for the cal curve) & %(N)s\\\hline 
            \bar{y_c}& %(ycbar)s\\\hline  S_c & %(Sc)s\\\hline  x_c & %(xc)s\\\hline  t-value used & 1.96 \\
        \hline

        \end{tabular}
        \end{center}"""
    d = {'Sxx': Sxx, 'Sxy': Sxy, 'ybar': np.mean(y), 'xbar': np.mean(x),
         'Sr': Sr, 'm': reg.slope, 'M': len(pre_y), 'N': len(x), 'ycbar': np.mean(pre_y), 'Sc': Sc, 'xc': xc}
        #   if not secondSample else {'ycbar': np.mean(pre_y), 'Sc': Sc, 'xc': xc}

    for i in d.keys():
        try:
            d[i] = round(d[i], 3)
        except:
            pass
    if not secondSample:
        table = table % d
    else:
        table = r"""\begin{center}
            \begin{tabular}{ |c|c| } 
            \hline 
                \bar{y_c}& %(ycbar)s\\\hline  S_c & %(Sc)s\\\hline  x_c & %(xc)s\\\hline  t-value used & 1.96 \\
            \hline

            \end{tabular}
            \end{center}""" %  {'ycbar': np.mean(pre_y), 'Sc': Sc, 'xc': xc}


    equationSection = r"""The above data is plugged into these equations and got the following data  
                $$
                m=\frac{S_{xy}}{S_{xx}}=\frac{%(Sxy)s}{%(Sxx)s}\; %(unit)s^{-1} = %(m)s %(unit)s^{-1}$$$$
                y_{int} = \bar y - m\bar x= %(ybar)s - %(m)s * %(barx)s\; %(unit)s = %(b)s\; %(unit)s 
                $$
                Sample 1 (1:%(dilutionFactor)s Diluted):
                $$
                S_c= %(dilutionFactor)s*\frac{S_r}{|m|}\sqrt{\frac{1}{M}+\frac{1}{N}+\frac{(\bar y_c -\bar y)^2}{m^2S_{xx}}}
                = %(dilutionFactor)s*\frac{%(Sr)s}{|%(m)s|}\sqrt{\frac{1}{%(M)s}+\frac{1}{%(N)s}+\frac{(%(ycbar)s -%(ybar)s)^2}{%(m)s^2*%(Sxx)s}} = %(Sc)s\; %(unit)s
                $$
                $$x_c=DilutionFactor*\frac{\bar y_c-b}{m}=%(dilutionFactor)s*
                \frac{%(ycbar)s-%(b)s}{%(m)s} = %(xc)s\; %(unit)s$$
                (Calculated by Chemstat.py, see appendix)
                $$RSD\%=\frac{S_c}{x_c}\times 100\% = \frac{%(Sc)s}{%(xc)s}\times 100\% = %(RSDp)s\%$$

                $$95\%CI=\pm t *s_c = \pm1.96*%(Sc)s\; %(unit)s=\mp %(CI)s \; %(unit)s$$
                $\therefore$ The 95\% CI of the conc of this sample is $%(roundedmean)s \pm %(roundedCI)s$ %(unit)s
    """
    # y_{int} = \bar y - m\bar x= %{ybar}s - %(m)s * %(barx)s %(unit)s = %(b)s %(unit)s
    #
    # %{'Sxx':Sxx, 'Sxy': Sxy, 'ybar':np.mean(y), 'barx': np.mean(x),
    # 'Sr':Sr, 'm':reg.slope, 'M':len(pre_y), 'N':len(x),'ycbar':np.mean(pre_y), 'Sc': Sc, 'xc': xc, "CI": 1.96*Sc, "Sc":Sc,
    # "unit": unit, "b":reg.intercept, 'dilutionFactor':dilutionFactor, 'RSDp':Sc/xc*100}
    replace = {'Sxx': Sxx, 'Sxy': Sxy, 'ybar': np.mean(y), 'barx': np.mean(x),
               'Sr': Sr, 'm': reg.slope, 'M': len(pre_y), 'N': len(x), 'ycbar': np.mean(pre_y), 'Sc': Sc, 'xc': xc, "CI": 1.96*Sc, "Sc": Sc,
               "unit": unit, "b": reg.intercept, 'dilutionFactor': dilutionFactor, 'RSDp': Sc/xc*100, "roundedmean": round(xc, 3-len(str(int(xc)).replace(".", ""))), "roundedCI": round(1.96*Sc, 3-len(str(int(1.96*Sc)).replace(".", "")))}

    for i in replace.keys():
        try:
            equationSection = equationSection.replace(
                "%("+i+")s", str(round(replace[i], 3)))
        except:
            equationSection = equationSection.replace(
                "%("+i+")s", str(replace[i]))

    print((r"The following is generated by chemstat.py\\ Raw Data" +
          raw_data+"Calc Curve"+table+equationSection).replace("\n", ""))


def removeOutlier(x, y):
    # CHEM_211_2022_Lab_Manual%20Final.pdf
    # G Value Table
    # Assume each point repeated 3 times
    # G = (X-Xbar)/s  Gc = 1.153
    x = np.array(x)
    y = np.array(y)
    y_reshaped = y.reshape((-1, 3))
    # print(y_reshaped)
    index = 0
    for i in y_reshaped:
        xbar = np.mean(i)
        for j in i:
            G = np.abs(j-xbar)/np.std(i, ddof=1) if np.std(i,
                                                           ddof=1) != 0 else 0  # forgot abs
            # print(G)
            if G >= 1.153:
                print(f"Removed a outlier {i} {j}")
                x = np.delete(x, index)
                y = np.delete(y, index)
            index += 1
    return x, y


def plotBestFit(ax, x, y):
    reg = linregress(x, y)
    # Xs is only 0[]]
    Xs = np.arange(np.min(x), np.max(x), (np.max(x)*1.1-np.min(x))*0.01)
    ax.plot(Xs, reg.slope*Xs+reg.intercept)
    ax.text(np.min(x), np.max(y), f"r^2={round(reg.rvalue**2,5)}")
    ax.text(np.min(x), np.max(
        y)*0.8, f"y={round(reg.slope,4)}x{'+' if reg.intercept>=0 else''}{round(reg.intercept,4)}")
